// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const createImagesTableIfNotExist = `-- name: CreateImagesTableIfNotExist :exec
CREATE TABLE IF NOT EXISTS images
(
    ship_name VARCHAR NOT NULL,
    image_url VARCHAR NOT NULL
)
`

func (q *Queries) CreateImagesTableIfNotExist(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createImagesTableIfNotExist)
	return err
}

const createPositionReportTableIfNotExist = `-- name: CreatePositionReportTableIfNotExist :exec
CREATE TABLE IF NOT EXISTS position_reports
(
    mmsi                        BIGINT PRIMARY KEY NOT NULL,
    ship_name                   VARCHAR            NOT NULL,
    latitude                    DOUBLE PRECISION   NOT NULL,
    longitude                   DOUBLE PRECISION   NOT NULL,
    cog                         INTEGER            NOT NULL,
    sog                         INTEGER            NOT NULL,
    true_heading                INTEGER            NOT NULL,
    navigational_status         INTEGER            NOT NULL,
    position_accuracy           BOOLEAN            NOT NULL,
    communication_state         BIGINT             NOT NULL,
    rate_of_turn                INTEGER            NOT NULL,
    special_manoeuvre_indicator INTEGER            NOT NULL,
    repeat_indicator            INTEGER            NOT NULL,
    message_id                  INTEGER            NOT NULL,
    valid                       BOOLEAN            NOT NULL,
    time_utc                    TIMESTAMP          NOT NULL,
    destination                 VARCHAR
)
`

func (q *Queries) CreatePositionReportTableIfNotExist(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPositionReportTableIfNotExist)
	return err
}

const emptyDBTables = `-- name: EmptyDBTables :exec
TRUNCATE TABLE position_reports
    RESTART IDENTITY CASCADE
`

func (q *Queries) EmptyDBTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, emptyDBTables)
	return err
}

const getPositionData = `-- name: GetPositionData :many
SELECT mmsi, ship_name, latitude, longitude, cog, sog, true_heading, navigational_status, position_accuracy, communication_state, rate_of_turn, special_manoeuvre_indicator, repeat_indicator, message_id, valid, time_utc, destination
FROM position_reports
WHERE latitude BETWEEN $1 AND $2 --minLat --maxLat
  AND longitude BETWEEN $3 AND $4
`

type GetPositionDataParams struct {
	Latitude    float64
	Latitude_2  float64
	Longitude   float64
	Longitude_2 float64
}

func (q *Queries) GetPositionData(ctx context.Context, arg GetPositionDataParams) ([]PositionReport, error) {
	rows, err := q.db.QueryContext(ctx, getPositionData,
		arg.Latitude,
		arg.Latitude_2,
		arg.Longitude,
		arg.Longitude_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PositionReport
	for rows.Next() {
		var i PositionReport
		if err := rows.Scan(
			&i.Mmsi,
			&i.ShipName,
			&i.Latitude,
			&i.Longitude,
			&i.Cog,
			&i.Sog,
			&i.TrueHeading,
			&i.NavigationalStatus,
			&i.PositionAccuracy,
			&i.CommunicationState,
			&i.RateOfTurn,
			&i.SpecialManoeuvreIndicator,
			&i.RepeatIndicator,
			&i.MessageID,
			&i.Valid,
			&i.TimeUtc,
			&i.Destination,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasImage = `-- name: HasImage :one
SELECT
    (image_url <> '') AS has_image
FROM images
WHERE ship_name = $1
`

func (q *Queries) HasImage(ctx context.Context, shipName string) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasImage, shipName)
	var has_image bool
	err := row.Scan(&has_image)
	return has_image, err
}

const setImageForShip = `-- name: SetImageForShip :exec
INSERT INTO images(ship_name, image_url)
VALUES ($1, $2)
`

type SetImageForShipParams struct {
	ShipName string
	ImageUrl string
}

func (q *Queries) SetImageForShip(ctx context.Context, arg SetImageForShipParams) error {
	_, err := q.db.ExecContext(ctx, setImageForShip, arg.ShipName, arg.ImageUrl)
	return err
}

const updateShipDestination = `-- name: UpdateShipDestination :exec


UPDATE position_reports
SET destination = $2
WHERE ship_name = $1
`

type UpdateShipDestinationParams struct {
	ShipName    string
	Destination sql.NullString
}

// minLon --maxLon
func (q *Queries) UpdateShipDestination(ctx context.Context, arg UpdateShipDestinationParams) error {
	_, err := q.db.ExecContext(ctx, updateShipDestination, arg.ShipName, arg.Destination)
	return err
}

const upsertPositionEntry = `-- name: UpsertPositionEntry :exec
INSERT INTO position_reports (mmsi,
                              ship_name,
                              latitude,
                              longitude,
                              cog,
                              sog,
                              true_heading,
                              navigational_status,
                              position_accuracy,
                              communication_state,
                              rate_of_turn,
                              special_manoeuvre_indicator,
                              repeat_indicator,
                              message_id,
                              valid,
                              time_utc)
VALUES ($1, -- mmsi
        $2, -- ship_name
        $3, -- latitude
        $4, -- longitude
        $5, -- cog
        $6, -- sog
        $7, -- true_heading
        $8, -- navigational_status
        $9, -- position_accuracy
        $10, -- communication_state
        $11, -- rate_of_turn
        $12, -- special_manoeuvre_indicator
        $13, -- repeat_indicator
        $14, -- message_id
        $15, --valid
        $16)
ON CONFLICT (mmsi) DO UPDATE
    SET ship_name                   = EXCLUDED.ship_name,
        latitude                    = EXCLUDED.latitude,
        longitude                   = EXCLUDED.longitude,
        cog                         = EXCLUDED.cog,
        sog                         = EXCLUDED.sog,
        true_heading                = EXCLUDED.true_heading,
        navigational_status         = EXCLUDED.navigational_status,
        position_accuracy           = EXCLUDED.position_accuracy,
        communication_state         = EXCLUDED.communication_state,
        rate_of_turn                = EXCLUDED.rate_of_turn,
        special_manoeuvre_indicator = EXCLUDED.special_manoeuvre_indicator,
        repeat_indicator            = EXCLUDED.repeat_indicator,
        message_id                  = EXCLUDED.message_id,
        valid                       = EXCLUDED.valid,
        time_utc                    = EXCLUDED.time_utc,
        destination                 = EXCLUDED.destination
`

type UpsertPositionEntryParams struct {
	Mmsi                      int64
	ShipName                  string
	Latitude                  float64
	Longitude                 float64
	Cog                       int32
	Sog                       int32
	TrueHeading               int32
	NavigationalStatus        int32
	PositionAccuracy          bool
	CommunicationState        int64
	RateOfTurn                int32
	SpecialManoeuvreIndicator int32
	RepeatIndicator           int32
	MessageID                 int32
	Valid                     bool
	TimeUtc                   time.Time
}

func (q *Queries) UpsertPositionEntry(ctx context.Context, arg UpsertPositionEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertPositionEntry,
		arg.Mmsi,
		arg.ShipName,
		arg.Latitude,
		arg.Longitude,
		arg.Cog,
		arg.Sog,
		arg.TrueHeading,
		arg.NavigationalStatus,
		arg.PositionAccuracy,
		arg.CommunicationState,
		arg.RateOfTurn,
		arg.SpecialManoeuvreIndicator,
		arg.RepeatIndicator,
		arg.MessageID,
		arg.Valid,
		arg.TimeUtc,
	)
	return err
}
